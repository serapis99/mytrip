"use strict";(self.webpackChunkmy_trip=self.webpackChunkmy_trip||[]).push([[3638],{3905:(e,n,r)=>{r.d(n,{Zo:()=>p,kt:()=>d});var a=r(7294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function t(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?t(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):t(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function i(e,n){if(null==e)return{};var r,a,o=function(e,n){if(null==e)return{};var r,a,o={},t=Object.keys(e);for(a=0;a<t.length;a++)r=t[a],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(a=0;a<t.length;a++)r=t[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=a.createContext({}),l=function(e){var n=a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},p=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var r=e.components,o=e.mdxType,t=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=l(r),d=o,f=m["".concat(c,".").concat(d)]||m[d]||u[d]||t;return r?a.createElement(f,s(s({ref:n},p),{},{components:r})):a.createElement(f,s({ref:n},p))}));function d(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var t=r.length,s=new Array(t);s[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<t;l++)s[l]=r[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},3549:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>l});var a=r(7462),o=(r(7294),r(3905));const t={},s="promesas",i={unversionedId:"WEB/javascript/peticiones_http/promesas",id:"WEB/javascript/peticiones_http/promesas",title:"promesas",description:"basicamente son objetos que en su interior tienen dos callbacks, por lo tanto los recibe como parametros a la hora de instanciar una promesa. normalmente estos parametros los llamamos resolve y reject cada uno recibe los datos a devolver dependiendo si se resolvio o si hubo un error.",source:"@site/docs/WEB/javascript/12_peticiones_http/03_promesas.md",sourceDirName:"WEB/javascript/12_peticiones_http",slug:"/WEB/javascript/peticiones_http/promesas",permalink:"/mytrip/docs/WEB/javascript/peticiones_http/promesas",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"JS",previous:{title:"Callbacks",permalink:"/mytrip/docs/WEB/javascript/peticiones_http/callbacks"},next:{title:"Fetch",permalink:"/mytrip/docs/WEB/javascript/peticiones_http/fetch"}},c={},l=[],p={toc:l};function u(e){let{components:n,...r}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"promesas"},"promesas"),(0,o.kt)("p",null,"basicamente son objetos que en su interior tienen dos callbacks, por lo tanto los recibe como parametros a la hora de instanciar una promesa. normalmente estos parametros los llamamos ",(0,o.kt)("strong",{parentName:"p"},"resolve")," y ",(0,o.kt)("strong",{parentName:"p"},"reject")," cada uno recibe los datos a devolver dependiendo si se resolvio o si hubo un error. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'\n//creamos un objeto users para simular una peticion a una base de datos users\nconst users=[\n    {\n        id:1,\n        name:"Dorian"\n    },{\n        id:2,\n        name:"Laura"\n    },{\n        id:3,\n        name:"Carlos"\n    }\n];\n//creamos un objeto emails para simular una segunda peticion a una base con los datos devueltos en users.\nconst emails=[\n    {\n        id:1,\n        email:\'dorian@gmail.com\'\n    },\n    {\n        id:2,\n        email:\'laura@gmail.com\'\n    }\n];\n\n\nconst getUser=(id)=>{\n    const user =users.find(user=>user.id==id); \n\n\n    const promise= new Promise((resolve,reject)=>{\n\n        if(!user){\n        //retornamos funcion cuando hay error\n        reject(`No existe un usuario con este ${id}`);\n    }else{\n        //retornamos funcion cuando no hay error\n        resolve(user);\n    } \n\n    });\n\n    return promise;\n}\n\n//funcion que sera llamada cuando se tenga los datos del usuario.\nconst getEmail =(user)=>{\n    const email=emails.find(email=>email.id==user.id);\n\n    const promise= new Promise((resolve,reject)=>{\n\n        if(!email){\n        //retornamos funcion cuando hay error\n        reject(`${user.name} no tiene email`);\n    }else{\n        //retornamos funcion cuando no hay error\n        resolve({\n            id:user.id,\n            name:user.name,\n            email:email.email\n        });\n    } \n\n    });\n\n    return promise;\n}\n\n//debido a que las promesas estan envueltas debemos usar la propiedad then() cuando no devuelve un error usamos catch \ngetUser(1)\n.then(user=>getEmail(user);)\n.then(res=>console.log(res);)\n.catch(err=>console.log(err););\n\n')),(0,o.kt)("p",null,"como se puede ver esto soluciona un poco el callback hell ya que no se comienza a alinear hacia la derecha por cada llamada. a su vez como ejecutamos una funcion con el parametro que nos retorna la promesa se puede simplificar mas el codigo que resuelve los datos."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"\n//forma simplificada \n\ngetUser(1)\n.then(getEmail)\n.then(console.log)\n.catch(console.log);\n\n")))}u.isMDXComponent=!0}}]);